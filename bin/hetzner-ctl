#!/usr/bin/env bash
#
# Hetzner Cloud Management CLI
# Simple primitives for managing Hetzner Cloud resources
#
# Usage: hetzner-ctl <command> [args...]
#
# Commands:
#   list-servers       List all servers
#   list-firewalls     List all firewalls
#   list-ssh-keys      List all SSH keys
#   list-images        List available images
#   list-types         List server types (sizes)
#   list-locations     List data center locations
#   list-all           List all resources (servers, firewalls, keys)
#
#   get-server <id>    Get server details
#   add-ssh-key [name] [keyfile]  Add SSH key (interactive or with args)
#   create-server [name] [type] [image] [location] [ssh-key]  Create server
#   delete-server <id> Delete a server
#
#   create-firewall <name> <ports> [--outbound <ports>]  Create firewall
#   apply-firewall <fw-id> <srv-id> Apply firewall to a server
#   get-firewall <id|name>  Show firewall rules
#   update-firewall <id|name> [options]  Update firewall rules
#   delete-firewall <id>            Delete a firewall
#
#   list-networks              List all networks
#   get-network <id>           Get network details
#   create-network <name> <ip-range>  Create a network
#   delete-network <id>        Delete a network
#
#   get-costs          Show current costs
#
#   ssh <name> [cmd]   SSH into server by name, optionally run command
#   status <name>      Show server status, IP, and type
#   console <id>       Get VNC console URL for a server
#   reboot <id>        Reboot a server
#   power-on <id>      Power on a server
#   power-off <id>     Power off a server
#
# Options:
#   -y, --yes          Skip confirmation prompts (for scripting)
#
# Environment:
#   HETZNER_API_TOKEN  API token (or ~/.hetzner/api_token)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0")")" && pwd)"
source "$SCRIPT_DIR/../lib/common.sh"

# Load token
load_token() {
    if ! load_credential "HETZNER_API_TOKEN" "$HOME/.hetzner/api_token"; then
        echo -e "${RED}Error: No API token found${NC}"
        echo "Set HETZNER_API_TOKEN or create ~/.hetzner/api_token"
        exit 1
    fi
}

# API request helper
api() {
    local method=$1
    local endpoint=$2
    local data=${3:-}

    local args=(
        -s
        -X "$method"
        -H "Authorization: Bearer ${HETZNER_API_TOKEN}"
        -H "Content-Type: application/json"
    )

    if [[ -n "$data" ]]; then
        args+=(-d "$data")
    fi

    curl "${args[@]}" "https://api.hetzner.cloud/v1${endpoint}"
}

# Commands
cmd_list_servers() {
    echo -e "${CYAN}=== Servers ===${NC}"
    local response
    response=$(api GET "/servers")

    local count
    count=$(echo "$response" | jq '.servers | length')

    if [[ "$count" == "0" ]]; then
        echo "No servers found"
        return
    fi

    echo "$response" | jq -r '.servers[] | "\(.id)\t\(.name)\t\(.server_type.name)\t\(.status)\t\(.public_net.ipv4.ip // "no-ip")\t\(.datacenter.name)"' | \
        column -t -s $'\t' -N "ID,NAME,TYPE,STATUS,IP,DATACENTER"
}

cmd_list_firewalls() {
    echo -e "${CYAN}=== Firewalls ===${NC}"
    local response
    response=$(api GET "/firewalls")

    local count
    count=$(echo "$response" | jq '.firewalls | length')

    if [[ "$count" == "0" ]]; then
        echo "No firewalls found"
        return
    fi

    echo "$response" | jq -r '.firewalls[] | "\(.id)\t\(.name)\t\(.rules | length) rules\t\(.applied_to | length) servers"' | \
        column -t -s $'\t' -N "ID,NAME,RULES,APPLIED_TO"
}

cmd_list_ssh_keys() {
    echo -e "${CYAN}=== SSH Keys ===${NC}"
    local response
    response=$(api GET "/ssh_keys")

    local count
    count=$(echo "$response" | jq '.ssh_keys | length')

    if [[ "$count" == "0" ]]; then
        echo "No SSH keys found"
        return
    fi

    echo "$response" | jq -r '.ssh_keys[] | "\(.id)\t\(.name)\t\(.fingerprint)"' | \
        column -t -s $'\t' -N "ID,NAME,FINGERPRINT"
}

cmd_list_images() {
    echo -e "${CYAN}=== Available Images (Ubuntu/Debian) ===${NC}"
    api GET "/images?type=system" | jq -r '.images[] | select(.os_flavor == "ubuntu" or .os_flavor == "debian") | "\(.id)\t\(.name)\t\(.os_flavor)\t\(.os_version)"' | \
        column -t -s $'\t' -N "ID,NAME,OS,VERSION"
}

cmd_list_types() {
    echo -e "${CYAN}=== Server Types ===${NC}"
    api GET "/server_types" | jq -r '.server_types[] | select(.deprecated == false) | "\(.name)\t\(.cores) vCPU\t\(.memory) GB\t\(.disk) GB\t€\(.prices[0].price_monthly.gross | tonumber | . * 100 | floor / 100)/mo"' | \
        sort -t$'\t' -k5 -n | \
        column -t -s $'\t' -N "TYPE,CPU,RAM,DISK,PRICE"
}

cmd_list_locations() {
    echo -e "${CYAN}=== Data Center Locations ===${NC}"
    api GET "/locations" | jq -r '.locations[] | "\(.name)\t\(.city)\t\(.country)\t\(.description)"' | \
        column -t -s $'\t' -N "ID,CITY,COUNTRY,DESCRIPTION"
}

cmd_list_all() {
    cmd_list_servers
    echo ""
    cmd_list_firewalls
    echo ""
    cmd_list_ssh_keys
}

cmd_get_server() {
    local server_id=$1

    if [[ -z "$server_id" ]]; then
        echo -e "${RED}Error: Server ID required${NC}"
        echo "Usage: $0 get-server <id>"
        exit 1
    fi

    api GET "/servers/$server_id" | jq '.server'
}

cmd_delete_server() {
    local server_id=$1

    if [[ -z "$server_id" ]]; then
        echo -e "${RED}Error: Server ID required${NC}"
        echo "Usage: $0 delete-server <id>"
        exit 1
    fi

    # Get server info first
    local server_info
    server_info=$(api GET "/servers/$server_id")
    local server_name
    server_name=$(echo "$server_info" | jq -r '.server.name')

    echo -e "${YELLOW}Warning: This will permanently delete server '$server_name' (ID: $server_id)${NC}"

    if ! confirm_action "Type the server name to confirm:" "$server_name"; then
        echo "Deletion cancelled"
        exit 1
    fi

    echo "Deleting server..."
    api DELETE "/servers/$server_id" | jq '.'
    echo -e "${GREEN}Server deleted${NC}"
}

cmd_add_ssh_key() {
    local name=${1:-}
    local key_file=${2:-}

    # Interactive mode if no args
    if [[ -z "$name" ]]; then
        read -p "SSH key name: " name
    fi

    if [[ -z "$key_file" ]]; then
        # Auto-detect key
        if [[ -f "$HOME/.ssh/id_ed25519.pub" ]]; then
            key_file="$HOME/.ssh/id_ed25519.pub"
        elif [[ -f "$HOME/.ssh/id_rsa.pub" ]]; then
            key_file="$HOME/.ssh/id_rsa.pub"
        else
            read -p "Path to public key: " key_file
        fi
    fi

    if [[ ! -f "$key_file" ]]; then
        echo -e "${RED}Error: Key file not found: $key_file${NC}"
        exit 1
    fi

    local public_key
    public_key=$(cat "$key_file")

    echo "Adding SSH key '$name' from $key_file..."
    local response
    response=$(api POST "/ssh_keys" "{\"name\": \"$name\", \"public_key\": \"$public_key\"}")

    if echo "$response" | jq -e '.ssh_key' > /dev/null 2>&1; then
        local key_id
        key_id=$(echo "$response" | jq -r '.ssh_key.id')
        echo -e "${GREEN}SSH key added with ID: $key_id${NC}"
    else
        echo -e "${RED}Error adding SSH key:${NC}"
        echo "$response" | jq '.'
        exit 1
    fi
}

cmd_create_server() {
    local name=${1:-}
    local server_type=${2:-}
    local image=${3:-}
    local location=${4:-}
    local ssh_key_name=${5:-}

    # Interactive mode if no args provided
    if [[ -z "$name" ]]; then
        echo -e "${CYAN}=== Create New Server ===${NC}"
        echo ""

        # Server name
        read -p "Server name: " name

        # Show types
        echo -e "\n${BLUE}Available server types:${NC}"
        cmd_list_types 2>/dev/null | head -15
        echo ""
        read -p "Server type [cpx11]: " server_type
        server_type=${server_type:-cpx11}

        # Show images
        echo -e "\n${BLUE}Available images:${NC}"
        api GET "/images?type=system" | jq -r '.images[] | select(.os_flavor == "ubuntu" or .os_flavor == "debian") | "\(.name)"' | sort -u | head -10
        echo ""
        read -p "Image [ubuntu-24.04]: " image
        image=${image:-ubuntu-24.04}

        # Show locations
        echo -e "\n${BLUE}Available locations:${NC}"
        api GET "/locations" | jq -r '.locations[] | "\(.name) - \(.city)"'
        echo ""
        read -p "Location [hil]: " location
        location=${location:-hil}

        # SSH key
        echo -e "\n${BLUE}SSH Keys:${NC}"
        local keys
        keys=$(api GET "/ssh_keys" | jq -r '.ssh_keys[] | "\(.name)"')
        if [[ -z "$keys" ]]; then
            echo "No SSH keys found. Add one first with: $0 add-ssh-key <name>"
            exit 1
        fi
        echo "$keys"
        echo ""
        read -p "SSH key name: " ssh_key_name
    fi

    # Defaults for non-interactive
    server_type=${server_type:-cpx11}
    image=${image:-ubuntu-24.04}
    location=${location:-hil}

    if [[ -z "$name" ]]; then
        echo -e "${RED}Error: Server name required${NC}"
        exit 1
    fi

    if [[ -z "$ssh_key_name" ]]; then
        echo -e "${RED}Error: SSH key name required${NC}"
        exit 1
    fi

    echo ""
    echo -e "Creating server:"
    echo -e "  Name:     ${GREEN}$name${NC}"
    echo -e "  Type:     $server_type"
    echo -e "  Image:    $image"
    echo -e "  Location: $location"
    echo -e "  SSH Key:  $ssh_key_name"
    echo ""

    if ! confirm_action "Proceed?"; then
        echo "Cancelled"
        exit 0
    fi

    echo "Creating server..."
    local response
    response=$(api POST "/servers" "{
        \"name\": \"$name\",
        \"server_type\": \"$server_type\",
        \"image\": \"$image\",
        \"location\": \"$location\",
        \"ssh_keys\": [\"$ssh_key_name\"],
        \"start_after_create\": true
    }")

    if echo "$response" | jq -e '.server' > /dev/null 2>&1; then
        local server_id ip
        server_id=$(echo "$response" | jq -r '.server.id')
        ip=$(echo "$response" | jq -r '.server.public_net.ipv4.ip')
        echo -e "${GREEN}Server created!${NC}"
        echo -e "  ID: $server_id"
        echo -e "  IP: $ip"
        echo ""
        echo "Wait ~30s for boot, then: ssh root@$ip"
    else
        echo -e "${RED}Error creating server:${NC}"
        echo "$response" | jq '.'
        exit 1
    fi
}

cmd_get_costs() {
    echo -e "${CYAN}=== Current Resource Costs ===${NC}"

    # Get all servers and calculate costs
    local servers
    servers=$(api GET "/servers")

    local total=0

    echo -e "\n${BLUE}Servers:${NC}"
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local name type price
            name=$(echo "$line" | cut -f1)
            type=$(echo "$line" | cut -f2)
            price=$(echo "$line" | cut -f3)
            total=$(echo "$total + $price" | bc)
            printf "  %-20s %-10s €%s/mo\n" "$name" "$type" "$price"
        fi
    done < <(echo "$servers" | jq -r '.servers[] | "\(.name)\t\(.server_type.name)\t\(.server_type.prices[0].price_monthly.gross)"')

    # Get floating IPs
    local floating_ips
    floating_ips=$(api GET "/floating_ips")
    local fip_count
    fip_count=$(echo "$floating_ips" | jq '.floating_ips | length')

    if [[ "$fip_count" != "0" ]]; then
        echo -e "\n${BLUE}Floating IPs:${NC}"
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local ip assigned
                ip=$(echo "$line" | cut -f1)
                assigned=$(echo "$line" | cut -f2)
                if [[ "$assigned" == "null" ]]; then
                    total=$(echo "$total + 4.00" | bc)
                    printf "  %-20s (unassigned) €4.00/mo\n" "$ip"
                else
                    printf "  %-20s (assigned)   €0.00/mo\n" "$ip"
                fi
            fi
        done < <(echo "$floating_ips" | jq -r '.floating_ips[] | "\(.ip)\t\(.server)"')
    fi

    echo -e "\n${GREEN}Estimated Monthly Total: €$total${NC}"
    echo -e "${YELLOW}Note: Does not include bandwidth overages or snapshots${NC}"
}

cmd_ssh() {
    local server_name=$1
    shift || true  # Remove server name from args, keep the rest

    if [[ -z "$server_name" ]]; then
        echo -e "${RED}Error: Server name required${NC}"
        echo "Usage: $0 ssh <name> [command...]"
        exit 1
    fi

    # Find server by name
    local response
    response=$(api GET "/servers?name=$server_name")

    local count
    count=$(echo "$response" | jq '.servers | length')

    if [[ "$count" == "0" ]]; then
        echo -e "${RED}Error: Server not found: $server_name${NC}"
        exit 1
    fi

    local ip
    ip=$(echo "$response" | jq -r '.servers[0].public_net.ipv4.ip')

    if [[ -z "$ip" || "$ip" == "null" ]]; then
        echo -e "${RED}Error: Server has no public IP${NC}"
        exit 1
    fi

    if [[ $# -gt 0 ]]; then
        # Execute command on server
        ssh -o StrictHostKeyChecking=accept-new "root@$ip" "$@"
    else
        # Interactive session
        echo -e "${CYAN}Connecting to $server_name ($ip)...${NC}"
        exec ssh "root@$ip"
    fi
}

cmd_status() {
    local server_name=$1

    if [[ -z "$server_name" ]]; then
        echo -e "${RED}Error: Server name required${NC}"
        echo "Usage: $0 status <name>"
        exit 1
    fi

    # Find server by name
    local response
    response=$(api GET "/servers?name=$server_name")

    local count
    count=$(echo "$response" | jq '.servers | length')

    if [[ "$count" == "0" ]]; then
        echo -e "${RED}Error: Server not found: $server_name${NC}"
        exit 1
    fi

    local server
    server=$(echo "$response" | jq '.servers[0]')

    local status ip type location created
    status=$(echo "$server" | jq -r '.status')
    ip=$(echo "$server" | jq -r '.public_net.ipv4.ip // "none"')
    type=$(echo "$server" | jq -r '.server_type.name')
    location=$(echo "$server" | jq -r '.datacenter.name')
    created=$(echo "$server" | jq -r '.created')
    server_id=$(echo "$server" | jq -r '.id')

    # Color status
    local status_color
    case "$status" in
        running)  status_color="${GREEN}${status}${NC}" ;;
        off)      status_color="${RED}${status}${NC}" ;;
        *)        status_color="${YELLOW}${status}${NC}" ;;
    esac

    echo -e "${CYAN}$server_name${NC}"
    echo -e "  Status:   $status_color"
    echo -e "  IP:       $ip"
    echo -e "  Type:     $type"
    echo -e "  Location: $location"
    echo -e "  ID:       $server_id"
    echo -e "  Created:  $created"
}

cmd_reboot() {
    local server_id=$1

    if [[ -z "$server_id" ]]; then
        echo -e "${RED}Error: Server ID required${NC}"
        echo "Usage: $0 reboot <id>"
        exit 1
    fi

    # Get server info
    local server_info
    server_info=$(api GET "/servers/$server_id")
    local server_name
    server_name=$(echo "$server_info" | jq -r '.server.name')

    echo -e "${YELLOW}Rebooting server '$server_name' (ID: $server_id)${NC}"

    if ! confirm_action "Proceed?"; then
        echo "Reboot cancelled"
        exit 0
    fi

    echo "Rebooting..."
    api POST "/servers/$server_id/actions/reboot" | jq '.action.status'
    echo -e "${GREEN}Reboot initiated${NC}"
}

cmd_power_on() {
    local server_id=$1

    if [[ -z "$server_id" ]]; then
        echo -e "${RED}Error: Server ID required${NC}"
        echo "Usage: $0 power-on <id>"
        exit 1
    fi

    # Get server info
    local server_info
    server_info=$(api GET "/servers/$server_id")
    local server_name
    server_name=$(echo "$server_info" | jq -r '.server.name')

    echo -e "${YELLOW}Powering on server '$server_name' (ID: $server_id)${NC}"

    if ! confirm_action "Proceed?"; then
        echo "Power on cancelled"
        exit 0
    fi

    echo "Powering on..."
    api POST "/servers/$server_id/actions/poweron" | jq '.action.status'
    echo -e "${GREEN}Power on initiated${NC}"
}

cmd_console() {
    local server_id=$1

    if [[ -z "$server_id" ]]; then
        echo -e "${RED}Error: Server ID required${NC}"
        echo "Usage: $0 console <id>"
        exit 1
    fi

    # Get server info
    local server_info
    server_info=$(api GET "/servers/$server_id")
    local server_name
    server_name=$(echo "$server_info" | jq -r '.server.name')

    echo -e "${CYAN}Requesting VNC console for '$server_name' (ID: $server_id)...${NC}"

    local response
    response=$(api POST "/servers/$server_id/actions/request_console")

    local wss_url password
    wss_url=$(echo "$response" | jq -r '.wss_url // empty')
    password=$(echo "$response" | jq -r '.password // empty')

    if [[ -z "$wss_url" ]]; then
        echo -e "${RED}Error: Failed to get console URL${NC}"
        echo "$response" | jq '.'
        exit 1
    fi

    echo ""
    echo -e "${GREEN}VNC Console Ready${NC}"
    echo ""
    echo "WebSocket URL: $wss_url"
    echo "Password:      $password"
    echo ""
    echo "Note: The console URL is valid for a limited time."
    echo "Use a WebSocket VNC client or Hetzner Cloud Console to connect."
}

cmd_power_off() {
    local server_id=$1

    if [[ -z "$server_id" ]]; then
        echo -e "${RED}Error: Server ID required${NC}"
        echo "Usage: $0 power-off <id>"
        exit 1
    fi

    # Get server info
    local server_info
    server_info=$(api GET "/servers/$server_id")
    local server_name
    server_name=$(echo "$server_info" | jq -r '.server.name')

    echo -e "${YELLOW}Warning: Powering off server '$server_name' (ID: $server_id)${NC}"
    echo "This is a hard power off. Use 'ssh' and 'shutdown' for graceful shutdown."

    if ! confirm_action "Proceed?"; then
        echo "Power off cancelled"
        exit 0
    fi

    echo "Powering off..."
    api POST "/servers/$server_id/actions/poweroff" | jq '.action.status'
    echo -e "${GREEN}Power off initiated${NC}"
}

# Firewall commands

cmd_create_firewall() {
    local name="" ports="" outbound_ports=""

    # Parse args: create-firewall <name> <ports> [--outbound <ports>]
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --outbound)
                outbound_ports="${2:-}"
                shift 2
                ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                elif [[ -z "$ports" ]]; then
                    ports="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        echo -e "${RED}Error: Firewall name required${NC}"
        echo "Usage: $0 create-firewall <name> <ports> [--outbound <ports>]"
        echo "  ports: comma-separated, e.g. 22,80,443,10000/udp"
        echo "  --outbound: comma-separated outbound ports"
        exit 1
    fi

    if [[ -z "$ports" ]]; then
        echo -e "${RED}Error: Inbound ports required${NC}"
        echo "Usage: $0 create-firewall <name> <ports> [--outbound <ports>]"
        echo "Example: $0 create-firewall my-fw 22,80,443 --outbound 80,443,53/udp"
        exit 1
    fi

    # Check if firewall already exists
    local existing
    existing=$(api GET "/firewalls" | jq -r ".firewalls[] | select(.name == \"$name\") | .id")

    if [[ -n "$existing" && "$existing" != "null" ]]; then
        echo -e "${YELLOW}Firewall '$name' already exists (ID: $existing)${NC}"
        echo "$existing"
        return 0
    fi

    # Build rules JSON
    local rules="["
    local first=true

    # Helper to add port rules
    _add_port_rules() {
        local port_csv=$1
        local direction=$2  # "in" or "out"
        local ip_field=$3   # "source_ips" or "destination_ips"

        IFS=',' read -ra port_list <<< "$port_csv"
        for port_spec in "${port_list[@]}"; do
            local port protocol="tcp"
            if [[ "$port_spec" == */udp ]]; then
                protocol="udp"
                port="${port_spec%/udp}"
            elif [[ "$port_spec" == */tcp ]]; then
                port="${port_spec%/tcp}"
            else
                port="$port_spec"
            fi

            if [[ "$first" != "true" ]]; then
                rules+=","
            fi
            first=false

            rules+="{\"direction\":\"$direction\",\"protocol\":\"$protocol\",\"port\":\"$port\",\"$ip_field\":[\"0.0.0.0/0\",\"::/0\"],\"description\":\"$direction $port/$protocol\"}"
        done
    }

    _add_port_rules "$ports" "in" "source_ips"

    if [[ -n "$outbound_ports" ]]; then
        _add_port_rules "$outbound_ports" "out" "destination_ips"
    fi

    # Always add ICMP inbound
    rules+=",{\"direction\":\"in\",\"protocol\":\"icmp\",\"source_ips\":[\"0.0.0.0/0\",\"::/0\"],\"description\":\"ICMP\"}"
    rules+="]"

    echo "Creating firewall '$name'"
    echo "  Inbound ports:  $ports"
    if [[ -n "$outbound_ports" ]]; then
        echo "  Outbound ports: $outbound_ports"
    fi

    if ! confirm_action "Proceed?"; then
        echo "Cancelled"
        exit 0
    fi

    local response
    response=$(api POST "/firewalls" "{\"name\": \"$name\", \"rules\": $rules}")

    local fw_id
    fw_id=$(echo "$response" | jq -r '.firewall.id')

    if [[ -z "$fw_id" || "$fw_id" == "null" ]]; then
        echo -e "${RED}Error: $(echo "$response" | jq -r '.error.message // "Unknown error"')${NC}"
        exit 1
    fi

    echo -e "${GREEN}Firewall created: $fw_id${NC}"
}

cmd_apply_firewall() {
    local fw_id=${1:-}
    local server_id=${2:-}

    if [[ -z "$fw_id" || -z "$server_id" ]]; then
        echo -e "${RED}Error: Firewall ID and server ID required${NC}"
        echo "Usage: $0 apply-firewall <firewall-id> <server-id>"
        exit 1
    fi

    echo "Applying firewall $fw_id to server $server_id..."
    local response
    response=$(api POST "/firewalls/$fw_id/actions/apply_to_resources" \
        "{\"apply_to\": [{\"type\": \"server\", \"server\": {\"id\": $server_id}}]}")

    local action_status
    action_status=$(echo "$response" | jq -r '.actions[0].status // .action.status // "unknown"')

    if [[ "$action_status" == "error" ]]; then
        echo -e "${RED}Error: $(echo "$response" | jq -r '.actions[0].error.message // .error.message // "Unknown error"')${NC}"
        exit 1
    fi

    echo -e "${GREEN}Firewall applied${NC}"
}

cmd_delete_firewall() {
    local fw_id=${1:-}

    if [[ -z "$fw_id" ]]; then
        echo -e "${RED}Error: Firewall ID required${NC}"
        echo "Usage: $0 delete-firewall <id>"
        exit 1
    fi

    # Get firewall info
    local fw_info
    fw_info=$(api GET "/firewalls/$fw_id")
    local fw_name
    fw_name=$(echo "$fw_info" | jq -r '.firewall.name')

    echo -e "${YELLOW}Deleting firewall '$fw_name' (ID: $fw_id)${NC}"

    if ! confirm_action "Proceed?"; then
        echo "Cancelled"
        exit 0
    fi

    api DELETE "/firewalls/$fw_id" > /dev/null
    echo -e "${GREEN}Firewall deleted${NC}"
}

# Resolve firewall by ID or name, sets FW_ID and FW_DATA
resolve_firewall() {
    local fw_ref=$1

    if [[ "$fw_ref" =~ ^[0-9]+$ ]]; then
        FW_DATA=$(api GET "/firewalls/$fw_ref")
    else
        local list_response
        list_response=$(api GET "/firewalls?name=$fw_ref")
        FW_DATA=$(echo "$list_response" | jq '{firewall: .firewalls[0]}')
    fi

    FW_ID=$(echo "$FW_DATA" | jq -r '.firewall.id // empty')

    if [[ -z "$FW_ID" ]]; then
        echo -e "${RED}Error: Firewall not found: $fw_ref${NC}"
        exit 1
    fi
}

cmd_get_firewall() {
    local fw_ref=${1:-}

    if [[ -z "$fw_ref" ]]; then
        echo -e "${RED}Error: Firewall ID or name required${NC}"
        echo "Usage: $0 get-firewall <id-or-name>"
        exit 1
    fi

    resolve_firewall "$fw_ref"
    local fw_name
    fw_name=$(echo "$FW_DATA" | jq -r '.firewall.name')

    echo -e "${CYAN}=== Firewall: $fw_name (ID: $FW_ID) ===${NC}"

    local applied_count
    applied_count=$(echo "$FW_DATA" | jq '.firewall.applied_to | length')
    echo -e "Applied to: $applied_count server(s)"

    echo ""
    echo -e "${BLUE}Inbound Rules:${NC}"
    local in_rules
    in_rules=$(echo "$FW_DATA" | jq -r '.firewall.rules[] | select(.direction == "in") | "\(.protocol)\t\(.port // "-")\t\(.source_ips | join(","))\t\(.description // "-")"')
    if [[ -z "$in_rules" ]]; then
        echo "  (none — all inbound traffic denied)"
    else
        echo "$in_rules" | column -t -s $'\t' -N "PROTO,PORT,SOURCE,DESC"
    fi

    echo ""
    echo -e "${BLUE}Outbound Rules:${NC}"
    local out_rules
    out_rules=$(echo "$FW_DATA" | jq -r '.firewall.rules[] | select(.direction == "out") | "\(.protocol)\t\(.port // "-")\t\(.destination_ips | join(","))\t\(.description // "-")"')
    if [[ -z "$out_rules" ]]; then
        echo "  (none — all outbound traffic allowed)"
    else
        echo "$out_rules" | column -t -s $'\t' -N "PROTO,PORT,DESTINATION,DESC"
    fi
}

# Pipe existing rules JSON, append new port rules, output updated JSON
# Usage: echo "$rules_json" | _build_rules_json "80,443,53/udp" "in" "source_ips"
_build_rules_json() {
    local port_csv=$1
    local direction=$2
    local ip_field=$3

    local existing
    existing=$(cat)

    IFS=',' read -ra port_list <<< "$port_csv"
    for port_spec in "${port_list[@]}"; do
        local port protocol="tcp"
        if [[ "$port_spec" == */udp ]]; then
            protocol="udp"
            port="${port_spec%/udp}"
        elif [[ "$port_spec" == */tcp ]]; then
            port="${port_spec%/tcp}"
        else
            port="$port_spec"
        fi

        existing=$(echo "$existing" | jq \
            --arg dir "$direction" \
            --arg proto "$protocol" \
            --arg p "$port" \
            --arg ipf "$ip_field" \
            --arg desc "$direction $port/$protocol" \
            '. + [{"direction": $dir, "protocol": $proto, "port": $p, ($ipf): ["0.0.0.0/0", "::/0"], "description": $desc}]')
    done

    echo "$existing"
}

cmd_update_firewall() {
    local fw_ref=""
    local add_inbound="" add_outbound="" remove_ports=""
    local set_inbound="" set_outbound=""
    local mode=""  # "merge" or "replace"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --add-inbound)   add_inbound="$2"; mode="merge"; shift 2 ;;
            --add-outbound)  add_outbound="$2"; mode="merge"; shift 2 ;;
            --remove)        remove_ports="$2"; mode="merge"; shift 2 ;;
            --set-inbound)   set_inbound="$2"; mode="replace"; shift 2 ;;
            --set-outbound)  set_outbound="$2"; mode="replace"; shift 2 ;;
            *)
                if [[ -z "$fw_ref" ]]; then
                    fw_ref="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$fw_ref" ]]; then
        echo -e "${RED}Error: Firewall ID or name required${NC}"
        echo "Usage: $0 update-firewall <id-or-name> [options]"
        echo ""
        echo "Merge mode (adds to / removes from existing rules):"
        echo "  --add-inbound <ports>   Add inbound rules"
        echo "  --add-outbound <ports>  Add outbound rules"
        echo "  --remove <ports>        Remove rules matching these ports"
        echo ""
        echo "Replace mode (replaces all rules):"
        echo "  --set-inbound <ports>   Set all inbound rules"
        echo "  --set-outbound <ports>  Set all outbound rules"
        exit 1
    fi

    if [[ -z "$mode" ]]; then
        echo -e "${RED}Error: At least one of --add-inbound, --add-outbound, --remove, --set-inbound, --set-outbound required${NC}"
        exit 1
    fi

    resolve_firewall "$fw_ref"
    local fw_name
    fw_name=$(echo "$FW_DATA" | jq -r '.firewall.name')

    local rules

    if [[ "$mode" == "replace" ]]; then
        # Build fresh rule set
        rules="[]"

        if [[ -n "$set_inbound" ]]; then
            rules=$(echo "$rules" | _build_rules_json "$set_inbound" "in" "source_ips")
        fi
        if [[ -n "$set_outbound" ]]; then
            rules=$(echo "$rules" | _build_rules_json "$set_outbound" "out" "destination_ips")
        fi

        # Add ICMP
        rules=$(echo "$rules" | jq '. + [{"direction":"in","protocol":"icmp","source_ips":["0.0.0.0/0","::/0"],"description":"ICMP"}]')

    else
        # Merge mode: start from existing rules
        rules=$(echo "$FW_DATA" | jq '.firewall.rules')

        if [[ -n "$remove_ports" ]]; then
            IFS=',' read -ra remove_list <<< "$remove_ports"
            for port_spec in "${remove_list[@]}"; do
                local port protocol="tcp"
                if [[ "$port_spec" == */udp ]]; then
                    protocol="udp"
                    port="${port_spec%/udp}"
                elif [[ "$port_spec" == */tcp ]]; then
                    port="${port_spec%/tcp}"
                else
                    port="$port_spec"
                fi
                rules=$(echo "$rules" | jq --arg p "$port" --arg pr "$protocol" '[.[] | select(.port != $p or .protocol != $pr)]')
            done
        fi

        if [[ -n "$add_inbound" ]]; then
            rules=$(echo "$rules" | _build_rules_json "$add_inbound" "in" "source_ips")
        fi
        if [[ -n "$add_outbound" ]]; then
            rules=$(echo "$rules" | _build_rules_json "$add_outbound" "out" "destination_ips")
        fi
    fi

    local rule_count
    rule_count=$(echo "$rules" | jq 'length')

    echo "Updating firewall '$fw_name' (ID: $FW_ID) with $rule_count rules:"
    echo "$rules" | jq -r '.[] | "  \(.direction) \(.protocol) \(.port // "-")"'

    if ! confirm_action "Proceed?"; then
        echo "Cancelled"
        exit 0
    fi

    local response
    response=$(api POST "/firewalls/$FW_ID/actions/set_rules" "{\"rules\": $rules}")

    local action_status
    action_status=$(echo "$response" | jq -r '.actions[0].status // "unknown"')

    if [[ "$action_status" == "error" ]]; then
        echo -e "${RED}Error: $(echo "$response" | jq -r '.actions[0].error.message // "Unknown error"')${NC}"
        exit 1
    fi

    echo -e "${GREEN}Firewall updated${NC}"
}

# Network commands

cmd_list_networks() {
    echo -e "${CYAN}=== Networks ===${NC}"
    local response
    response=$(api GET "/networks")

    local count
    count=$(echo "$response" | jq '.networks | length')

    if [[ "$count" == "0" ]]; then
        echo "No networks found"
        return
    fi

    echo "$response" | jq -r '.networks[] | "\(.id)\t\(.name)\t\(.ip_range)\t\(.subnets | length) subnets\t\(.servers | length) servers"' | \
        column -t -s $'\t' -N "ID,NAME,IP_RANGE,SUBNETS,SERVERS"
}

cmd_get_network() {
    local net_id=${1:-}

    if [[ -z "$net_id" ]]; then
        echo -e "${RED}Error: Network ID required${NC}"
        echo "Usage: $0 get-network <id>"
        exit 1
    fi

    local response
    response=$(api GET "/networks/$net_id")

    local net_name ip_range
    net_name=$(echo "$response" | jq -r '.network.name // empty')

    if [[ -z "$net_name" ]]; then
        echo -e "${RED}Error: Network not found: $net_id${NC}"
        exit 1
    fi

    ip_range=$(echo "$response" | jq -r '.network.ip_range')

    echo -e "${CYAN}=== Network: $net_name (ID: $net_id) ===${NC}"
    echo -e "IP Range: $ip_range"

    echo ""
    echo -e "${BLUE}Subnets:${NC}"
    local subnets
    subnets=$(echo "$response" | jq -r '.network.subnets[] | "\(.ip_range)\t\(.type)\t\(.network_zone)"')
    if [[ -z "$subnets" ]]; then
        echo "  (none)"
    else
        echo "$subnets" | column -t -s $'\t' -N "IP_RANGE,TYPE,ZONE"
    fi

    echo ""
    echo -e "${BLUE}Servers:${NC}"
    local servers
    servers=$(echo "$response" | jq -r '.network.servers[]' 2>/dev/null)
    if [[ -z "$servers" ]]; then
        echo "  (none)"
    else
        for srv_id in $servers; do
            local srv_info
            srv_info=$(api GET "/servers/$srv_id")
            local srv_name srv_ip
            srv_name=$(echo "$srv_info" | jq -r '.server.name')
            srv_ip=$(echo "$srv_info" | jq -r ".server.private_net[] | select(.network == $net_id) | .ip")
            echo "  $srv_id  $srv_name  $srv_ip"
        done
    fi
}

cmd_create_network() {
    local name=${1:-}
    local ip_range=${2:-}

    if [[ -z "$name" || -z "$ip_range" ]]; then
        echo -e "${RED}Error: Name and IP range required${NC}"
        echo "Usage: $0 create-network <name> <ip-range>"
        echo "Example: $0 create-network my-net 10.0.0.0/16"
        exit 1
    fi

    echo "Creating network '$name' with range $ip_range"

    if ! confirm_action "Proceed?"; then
        echo "Cancelled"
        exit 0
    fi

    local response
    response=$(api POST "/networks" "{\"name\": \"$name\", \"ip_range\": \"$ip_range\"}")

    local net_id
    net_id=$(echo "$response" | jq -r '.network.id')

    if [[ -z "$net_id" || "$net_id" == "null" ]]; then
        echo -e "${RED}Error: $(echo "$response" | jq -r '.error.message // "Unknown error"')${NC}"
        exit 1
    fi

    echo -e "${GREEN}Network created: $net_id${NC}"
}

cmd_delete_network() {
    local net_id=${1:-}

    if [[ -z "$net_id" ]]; then
        echo -e "${RED}Error: Network ID required${NC}"
        echo "Usage: $0 delete-network <id>"
        exit 1
    fi

    local net_info
    net_info=$(api GET "/networks/$net_id")
    local net_name
    net_name=$(echo "$net_info" | jq -r '.network.name')

    echo -e "${YELLOW}Deleting network '$net_name' (ID: $net_id)${NC}"

    if ! confirm_action "Proceed?"; then
        echo "Cancelled"
        exit 0
    fi

    api DELETE "/networks/$net_id" > /dev/null
    echo -e "${GREEN}Network deleted${NC}"
}

# Main
main() {
    parse_global_flags "$@"
    set -- "${REMAINING_ARGS[@]}"

    local cmd=${1:-}

    if [[ -z "$cmd" ]]; then
        usage "$0"
    fi

    load_token

    case "$cmd" in
        list-servers)    cmd_list_servers ;;
        list-firewalls)  cmd_list_firewalls ;;
        list-ssh-keys)   cmd_list_ssh_keys ;;
        list-images)     cmd_list_images ;;
        list-types)      cmd_list_types ;;
        list-locations)  cmd_list_locations ;;
        list-all)        cmd_list_all ;;
        get-server)      cmd_get_server "${2:-}" ;;
        add-ssh-key)     cmd_add_ssh_key "${2:-}" "${3:-}" ;;
        create-server)   cmd_create_server "${2:-}" "${3:-}" "${4:-}" "${5:-}" "${6:-}" ;;
        delete-server)   cmd_delete_server "${2:-}" ;;
        create-firewall) shift; cmd_create_firewall "$@" ;;
        apply-firewall)  cmd_apply_firewall "${2:-}" "${3:-}" ;;
        delete-firewall) cmd_delete_firewall "${2:-}" ;;
        get-firewall)    cmd_get_firewall "${2:-}" ;;
        update-firewall) shift; cmd_update_firewall "$@" ;;
        list-networks)   cmd_list_networks ;;
        get-network)     cmd_get_network "${2:-}" ;;
        create-network)  cmd_create_network "${2:-}" "${3:-}" ;;
        delete-network)  cmd_delete_network "${2:-}" ;;
        get-costs)       cmd_get_costs ;;
        ssh)             shift; cmd_ssh "$@" ;;
        status)          cmd_status "${2:-}" ;;
        console)         cmd_console "${2:-}" ;;
        reboot)          cmd_reboot "${2:-}" ;;
        power-on)        cmd_power_on "${2:-}" ;;
        power-off)       cmd_power_off "${2:-}" ;;
        -h|--help|help)  usage "$0" ;;
        *)
            echo -e "${RED}Unknown command: $cmd${NC}"
            usage "$0"
            ;;
    esac
}

main "$@"
